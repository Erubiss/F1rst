import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:f1rst/models/user_model.dart';
import 'package:f1rst/state_managers/state.dart';
import 'package:f1rst/views/home_page.dart';
import 'package:f1rst/views/splash_screen.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:image_picker/image_picker.dart';

class RegInfoCubit extends Cubit<RegInfoState> {
  RegInfoCubit() : super(RegInfoState.initial());
  final firestore = FirebaseFirestore.instance;
  final auth = FirebaseAuth.instance;
  final picker = ImagePicker();
  final storage = FirebaseStorage.instance;
  final _storegeRef = FirebaseStorage.instance.ref('images/');

  void onSubmitted({
    
    required String email,
    required String phoneNumber,
    required String password,
    required String confirmPassword,
    required String userImage,
    required BuildContext context,
    String aboutUser = '',
  }) async {
    validateEmail(email);
    validatePhoneNumber(phoneNumber);
    validatePasswords(password, confirmPassword);

    if (state.isEmailError ||
        state.isPhoneNumberError ||
        state.isPasswordError) {
      return;
    }

    try {
      final credential = await auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );

      await firestore.collection('user').doc(auth.currentUser!.uid).set({
        'email': email,
        'phoneNumber': phoneNumber,
        'aboutUser': aboutUser,
        'userImage': userImage,
      });

      print(credential);

      Navigator.push(
          context, MaterialPageRoute(builder: (context) => HomePage()));
    } catch (e) {
      print(e);
    }
  }

  void getUser() async {
    try {
      emit(state.copyWith(isLoading: true));
      if (auth.currentUser == null) return;
      final res =
          await firestore.collection('user').doc(auth.currentUser!.uid).get();

      if (res.data() != null) {
        final UserModel user = UserModel.fromMap(res.data()!);
        emit(
          state.copyWith(
            user: user,
          ),
        );
        print(state.user);
      }
      emit(state.copyWith(isLoading: false));
    } catch (e) {
      print(e);
    }
  }

  void updateUserAbout(TextEditingController ctrl) async {
    try {
      await firestore
          .collection("user")
          .doc(auth.currentUser!.uid)
          .update({"aboutUser": ctrl.text});
      getUser();
    } catch (e) {
      print(e);
    } finally {
      ctrl.clear();
    }
  }

  void deleteUser(BuildContext context) async {
    try {
      await firestore.collection('user').doc(auth.currentUser!.uid).delete();
      await auth.currentUser!.delete();
      Navigator.push(
          context, MaterialPageRoute(builder: (context) => SplashScreen()));
    } catch (e) {
      print(e);
    }
  }

  void pickImage() async {
    try {
      final pickedFile = await picker.pickImage(source: ImageSource.gallery);
      if (pickedFile != null) {
        final userImage = await uploadImageToFirebase(pickedFile);
        await firestore
            .collection("user")
            .doc(auth.currentUser!.uid)
            .set({"userImage": userImage});

        final userDoc =
            await firestore.collection("user").doc(auth.currentUser!.uid).get();

        print(userDoc);

        // Do something with the updated user data
        print("User image updated: ${userDoc['userImage']}");
      }
    } catch (e) {
      print(e);
    }
  }

  Future<String> uploadImageToFirebase(XFile pickedFile) async {
    try {
      Reference? imageRef = _storegeRef.child(pickedFile.path);
      final UploadTask uploadTask = imageRef.putFile(File(pickedFile.path));
      return (await uploadTask).ref.getDownloadURL();
    } catch (e) {
      print("Error uploading image: $e");
      throw e;
    }
  }

  void logIn(String email, String password, BuildContext context) async {
    try {
      final res = await FirebaseAuth.instance.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      print(res);

      Navigator.push(
          context, MaterialPageRoute(builder: (context) => HomePage()));
    } catch (e) {
      print(e);
    }
  }

  void validateEmail(String email) {
    final errorMessage = getEmailErrorMessage(email);
    emit(state.copyWith(
      emailMessage: errorMessage,
      isEmailError: errorMessage.isNotEmpty,
    ));
  }

  void validatePhoneNumber(String phoneNumber) {
    final errorMessage = getPhoneErrorMessage(phoneNumber);
    emit(state.copyWith(
      phoneNumberMessage: errorMessage,
      isPhoneNumberError: errorMessage.isNotEmpty,
    ));
  }

  void validatePasswords(String password, String confirmPassword) {
    final errorMessage = getPasswordErrorMessage(password, confirmPassword);
    emit(state.copyWith(
      passwordMessage: errorMessage,
      isPasswordError: errorMessage.isNotEmpty,
    ));
  }

  void updatePhoneNumber(String phoneNumber) {
    emit(state.copyWith(phoneNumber: phoneNumber));
  }

  void updatePassword(String password) {
    emit(state.copyWith(password: password));
  }

  void updateAboutUser(String aboutUser) {
    emit(state.copyWith(aboutUser: aboutUser));
  }

  String getPasswordErrorMessage(String password, String confirmPassword) {
    if (password.isEmpty || confirmPassword.isEmpty) {
      return 'Password fields cannot be empty';
    }
    if (password != confirmPassword) {
      return 'Passwords do not match';
    }
    if (password.length < 6) {
      return 'Password is too short';
    }
    return '';
  }

  String getEmailErrorMessage(String email) {
    switch (email.getEmailValidationState()) {
      case EmailValidationState.empty:
        return 'The email is empty';
      case EmailValidationState.invalid:
        return 'Incorrect email';
      case EmailValidationState.valid:
        return '';
    }
  }

  String getPhoneErrorMessage(String phone) {
    switch (phone.getPhoneValidationState()) {
      case PhoneNumberValidationState.empty:
        return 'Please fill your phone number';
      case PhoneNumberValidationState.notFull:
        return 'Invalid number';
      case PhoneNumberValidationState.valid:
        return '';
    }
  }
}

extension EmailValidation on String {
  EmailValidationState getEmailValidationState() {
    if (this.isEmpty) {
      return EmailValidationState.empty;
    }
    final regex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
    if (!regex.hasMatch(this)) {
      return EmailValidationState.invalid;
    }
    return EmailValidationState.valid;
  }
}

extension PhoneNumberValidation on String {
  PhoneNumberValidationState getPhoneValidationState() {
    if (this.isEmpty) {
      return PhoneNumberValidationState.empty;
    }
    if (this.length < 10) {
      return PhoneNumberValidationState.notFull;
    }
    return PhoneNumberValidationState.valid;
  }
}

enum EmailValidationState {
  empty,
  invalid,
  valid,
}

enum PhoneNumberValidationState {
  empty,
  notFull,
  valid,
}

enum PasswordValidationState {
  empty,
  notMatching,
  invalid,
  valid,
}